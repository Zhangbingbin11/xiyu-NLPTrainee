#1.1有效的括号
def isValid(s):
    """
    :type s: str
    :rtype: bool
    """
    stack = []
    mapping = {")": "(", "}": "{", "]": "["}
    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    return not stack
s = input("Please input s:")
ans=isValid(s)
print(ans)

#1.2括号生成（回溯法）
class Solution(object):
    def generateParenthesis(self, N):
        ans = []
        def backtrack(S = '', left = 0, right = 0):
            if len(S) == 2 * N:
                ans.append(S)
                return
            if left < N:
                backtrack(S+'(', left+1, right)
            if right < left:
                backtrack(S+')', left, right+1)
        backtrack()
        return ans
a = Solution()
ans = a.generateParenthesis(3)
print(ans)

# 1.3最长的有效括号
class Solution():
    def longestValidParentheses(self, s: str) -> int:
        n = len(s)
        if n == 0: return 0
        dp = [0] * n
        res = 0
        for i in range(n):
            if i>0 and s[i] == ")":
                if  s[i - 1] == "(":
                    dp[i] = dp[i - 2] + 2
                elif s[i - 1] == ")" and i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == "(":
                    dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2]
                if dp[i] > res:
                    res = dp[i]
        return res
a = Solution()
res = a.longestValidParentheses(")((()))()")
print(res)

#1.4替换空格
# 方法一：直接用接口
class Solution():
    def replaceSpace(self,s):
        return s.replace(' ','%20')
a = Solution()
str =a.replaceSpace("We Are Happy.")
print(str)
#方法二：在python中字符串不可变 时间复杂度O(n),空间O(n)
class Solution():
    def replaceSpace(self,s):
        res = ''
        for i in s:
            if i == ' ':
                res += '%20'
            else:
                res += i
        return res
a = Solution()
res = a.replaceSpace("WE ARE HAPPY.")
print(res)
#方法三：通用(两个指针p1,p2) 时间O(n^2)
def replaceSpace(s):
    p1 = len(s) - 1
    res = list(s)
    n = s.count(' ')
    res += [0] * n * 2
    p2 = len(res) - 1
    while p1 != p2:
        if res[p1] == ' ':
            res[p2] = '0'
            res[p2 - 1] = '2'
            res[p2 - 2] = '%'
            p2 -= 3
        else:
            res[p2] = res[p1]
            p2 -= 1
        p1 -= 1
    return ''.join(res)
s_res = replaceSpace("we are happy.")
print(s_res)


#1.5Pandas基础
# pandas 遍历有以下三种方法
# .iterrows（）：在单独的变量中返回索引和行项目，但显着较慢
# .itertuples（）：快于.iterrows（），但将索引与行项目一起返回，ir [0]是索引
# zip：最快，但不能访问该行的索引
import numpy as np
import pandas as pd
# pd.show_versions()
mylist = list('abcdefghijklmnopqrstuvwxyz')
myarr = np.arange(26)
mydict = dict(zip(mylist,myarr))
# print(mydict)
#列表，数组，字典转化为series
ser1 = pd.Series(mylist)
ser2 = pd.Series(myarr)
ser3 = pd.Series(mydict)
print(ser3.head()) #series的idex转化为dataframe的column
s1 = ser1[:10]
s2 = ser2[10:]
print(pd.concat([s1,s2],axis=0))#头尾拼接两个series
sA = pd.Series([1,2,3,4,5,6])
sB = pd.Series([5,6,7,8,9,10])
print(sA[~sA.isin(sB)])#元素在sA不在sB
